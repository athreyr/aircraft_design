function [inputPropertiesList, valuesList, OtherInputs] = ...
                                        parseInputs(Default, userInputValues)
%UNPACK Summary of this function goes here
%   Detailed explanation goes here
% This class can be initialised in the following ways:
% AM = AtmosphericModel(deltaT, |[hMax dh hMin], |[hUb lapseRates], |Ref, |SaveUnits);
% AM = AtmosphericModel([hG T], [hGUb isGrad], |Ref, |SaveUnits);

% instead of OtherInputs, use deltaT from h, T, p, rho, pressure altitude,
% density altitude, etc. - that's how it's actually done when looking up
% altitudes on hot/cold days.

inputPropertiesList = { ...
    'regionLimitsGeopotential'; ...
    'lapseRates'; ...
    'RADIUS_OF_EARTH'; ...
    'ACCELERATION_DUE_TO_GRAVITY'; ...
    'SaveUnits'; ...
    'DisplayUnits' ...
    };

valuesList = { ...
    [Default.hMin; Default.hUb]; ...
    Default.lapseRates; ...
    Default.Ref.RADIUS_OF_EARTH; ...
    Default.Ref.ACCELERATION_DUE_TO_GRAVITY; ...
    Default.SaveUnits; ...
    Default.SaveUnits ...
    };

OtherInputs = struct( ...
    'hMin', Default.hMin, ...
    'dh', Default.dh, ...
    'hMax', Default.hMax, ...
    'hRef', Default.Ref.h, ...
    'TRef', Default.Ref.T, ...
    'pRef', Default.Ref.p, ...
    'rhoRef', Default.Ref.rho, ...
    'deltaT', Default.deltaT ...
    );

if isempty(userInputValues), return, end

if isscalar(userInputValues{1}) % deltaT, hData, regionData, Reference, Units
    
    deltaT = userInputValues{1};
    
    defaultValues = { ...
        [Default.hMax Default.dh Default.hMin], ...
        [Default.hUb Default.lapseRates], ...
        Default.Ref, ...
        Default.SaveUnits ...
        };
    
    [hData, regionData, Reference, Units] = ...
                    setOptionalInputs(defaultValues, userInputValues(2:end));
    
    str = 'AtmosphericModel';
    try
        validateattributes(deltaT, {'numeric'}, {'nonempty','scalar'}, ...
            str, 'deltaT', 1)
        validateattributes(hData, {'numeric'}, {'nonempty','vector'}, ...
            str, '[hMax dh hMin]', 2)
        validateattributes(regionData, {'numeric'}, {'nonempty','ncols',2}, ...
            str, '[hUb lapseRates]', 3)
        validateattributes(Reference, {'struct'}, {'nonempty','scalar'}, ...
            str, 'Ref', 4)
        validateattributes(Units, {'struct'}, {'nonempty','scalar'}, ...
            str, 'SaveUnits', 5)
    catch ME
        ME.throwAsCaller
    end
    
    hData(numel(hData):3) = nan; % replace empty numbers with nan
    dfltIdx = isnan(hData); % collect all (potentially input by user) nan indices
    hData(dfltIdx) = defaultValues{1}(dfltIdx); % replace them with default values
    
    % sort regionData by altitude limits
    [hUb, isrt_hUb] = sort(regionData(:,1));
    lapseRates = regionData(isrt_hUb,2);
    
    % add default fields to Reference and Units
    Reference = setfieldnew(Reference, Default.Ref);
    Units = setfieldnew(Units, Default.SaveUnits);
    
    % issue warnings and adjust data for hMin, hMax, hRef, and hUb
    hMin = hData(3);
    hMax = hData(1);
    if hMin > hMax
        warning('AD:AtmosphericModel:altitudeMinMaxSwap', ...
            ['Minimum altitude %g %s is more than maximum altitude %g %s,' ...
            ' so interchanging them'], ...
            hMin, Units.altitude, hMax, Units.altitude)
        [hMin, hMax] = deal(hMax, hMin);
    end
    
    if hMax > hUb(end)
        warning('AD:AtmosphericModel:maxAltAboveRegLim', ...
            ['Maximum altitude %g %s is higher than the last region limit ' ...
            '%g %s, so bringing it down to the limit'], ...
            hMax, Units.altitude, hUb(end), Units.altitude)
        hMax = hUb(end);
    end
    
    hRef = Reference.h;
    iRef = find(hUb > hRef, 1);
    if iRef > 1
        warning('AD:AtmosphericModel:refAltAboveRegLim', ...
            ['Reference altitude %g %s is higher than region limit %g ' ...
            '%s. Lowest altitude has been adjusted from %g %s to %g %s'], ...
            hRef, Units.altitude, hUb(iRef), Units.altitude, ...
            hMin, Units.altitude, hUb(iRef), Units.altitude);
        hMin = hUb(iRef);
    end
    
    dh = hData(2);
    if dh > hRef - hMin
        warning('AD:AtmosphericModel:minAltAbovePrecision', ...
            ['Minimum altitude %g %s is more than one step of %g %s below' ...
            ' the reference altitude %g %s, so reducing it to %g %s'], ...
            hMin, Units.altitude, dh, Units.altitude, hRef, Units.altitude, ...
            hMin - dh, Units.altitude)
        hMin = hMin - dh;
    end
    
    valuesList = { ...
        [hMin; hUb]; ...
        lapseRates; ...
        Reference.RADIUS_OF_EARTH; ...
        Reference.ACCELERATION_DUE_TO_GRAVITY; ...
        Units; ...
        Units ...
    };
    
    OtherInputs.hMin = hMin;
    OtherInputs.dh = dh;
    OtherInputs.hMax = hMax;
    OtherInputs.hRef = hRef;
    OtherInputs.TRef = Reference.T;
    OtherInputs.pRef = Reference.p;
    OtherInputs.rhoRef = Reference.rho;
    OtherInputs.deltaT = deltaT;
    
elseif isnumeric(userInputValues{1}) % hGTData, regionData, Reference, Units
    
    % if you're using this, you can't give pressure at arbitrary height,
    % you need to give it at hG(1)
    
    hGTData = userInputValues{1};
    regionData = userInputValues{2};
    
    defaultValues = { ...
        Default.Ref, ...
        Default.SaveUnits ...
        };
    
    [Reference, Units] = ...
                    setOptionalInputs(defaultValues, userInputValues(3:end));
    
    str = 'AtmosphericModel';
    try
        validateattributes(hGTData, {'numeric'}, {'nonempty','ncols',2}, ...
            str, '[hG T]', 1)
        validateattributes(regionData, {'numeric'}, {'nonempty','ncols',2}, ...
            str, '[hGUb isGradReg]',2)
        validateattributes(Reference, {'struct'}, {'nonempty','scalar'}, ...
            str, 'Ref', 3)
        validateattributes(Units, {'struct'}, {'nonempty','scalar'}, ...
            str, 'SaveUnits', 4)
    catch ME
        ME.throwAsCaller
    end
    
    [hG, isrt_hG] = sort(hGTData(:,1));
    T = hGTData(isrt_hG,2);
    
    [hGUb, isrt_hGUb] = sort(regionData(:,1));
    isGradReg = regionData(isrt_hGUb,2);
    
    hGRegLim = [hG(1); hGUb];
    
    Reference = setfieldnew(Reference, Default.Ref);
    % there's no reference height when user is using this form of the
    % constructor, so remove that field (temperature and density will still
    % be used to compute specific gas constant, so keep them)
    Reference = rmfield(Reference, 'h');
    
    Units = setfieldnew(Units, Default.SaveUnits);
    
    inputPropertiesList = { ...
        'temperatures'; ...
        'RADIUS_OF_EARTH'; ...
        'ACCELERATION_DUE_TO_GRAVITY'; ...
        'SaveUnits'; ...
        'DisplayUnits' ...
        };
    
    valuesList = { ...
        T; ...
        Reference.RADIUS_OF_EARTH; ...
        Reference.ACCELERATION_DUE_TO_GRAVITY; ...
        Units; ...
        Units ...
    };

    OtherInputs.hG = hG;
    OtherInputs.hGRegLim = hGRegLim;
    OtherInputs.isGradReg = isGradReg;
    OtherInputs.hRef = Reference.h;
    OtherInputs.TRef = Reference.T;
    OtherInputs.pRef = Reference.p;
    OtherInputs.rhoRef = Reference.rho;

else
    
    warning('AD:AtmosphericModel:ambiguousSyntax', ...
        'Unknown or ambiguous syntax. Proceeding with default values')
    
end % if block for multiple function signatures

end % function
